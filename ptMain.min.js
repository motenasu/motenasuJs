// src/index.js
// import { filter } from "core-js/core/array";
// import "core-js/stable";
// import "regenerator-runtime/runtime";
import smoothscroll from 'smoothscroll-polyfill';

// import objectFitImages from 'object-fit-images';
// import {dropdown} from './module/_mod_dropdown';
//参考: https://notes.sharesl.net/articles/1601/#%e3%83%96%e3%83%a9%e3%82%a6%e3%82%b6%e5%af%be%e5%bf%9c%e7%8a%b6%e6%b3%81
// const imagesLoaded = require('imagesloaded');
require('intersection-observer');
smoothscroll.polyfill();
function bodyClsContains(cls){
  if(document.body.hasAttribute("class")){
    const bodyCls = document.body.getAttribute('class').split(' ');
    const contains = bodyCls.indexOf(cls) > -1;
    return contains;
  }else{
    return false;
  }
}
const BREAK_POPINT = 900;

//breakpointで一回だけfunctionを動かす
function switchEvent(bp=800,func){

  const breakPoint = bp;
  let resizeBool ;

  window.addEventListener('load',()=>{
    if( breakPoint < window.innerWidth){
      func.mqMin();
      resizeBool = false;
    }else{
      func.mqMax();
      resizeBool = true;
    }
  },false);
  
  window.addEventListener('resize',()=>{
    if( breakPoint < window.innerWidth && resizeBool){
      func.mqMin();
      resizeBool = false;
    }else if( breakPoint >= window.innerWidth && !(resizeBool)){
      func.mqMax();
      resizeBool = true;
    }
  },false);
  
};

//offsetでトップからの距離で反応する関数(classのswap)
//addEventListenerを外部関数加する際は引数eventを必ずつける。
function scrollOffset(event, ID, offset) {
  const wrapID = window.document.querySelector(ID);
  const doch = window.pageYOffset || document.documentElement.scrollTop; //トップからの現在位置を表示
  if (doch > offset) {
    wrapID.classList.remove('closedMove');
    wrapID.classList.add('openMove');
    wrapID.style.display = "block"; //読み込み時の不自然な変形を見せないため
  } else if (document.body.classList.contains('active-style') == false && doch < offset) {
    wrapID.classList.remove('openMove');
    wrapID.classList.add('closedMove');
  }
};


window.document.addEventListener('scroll', (event) => {
  scrollOffset(event, '#scroll-top', 600);
  scrollOffset(event, '#ym-glnav-2', 300);

}, !document.documentMode ? {
  passive: true
} : false);

if ( typeof( window.glnavAreaAdjust ) == "undefined" ) {
  function glnavAreaAdjust(arr=[]) {
    const offcan = document.getElementById('ym-offcan');
    const hamb = document.getElementById('hamb-btn__1');
    const offcanInn = '.ym-offcan__area-inn';
    const offcanVar = '--ym-offcan-height';
    const glnavID = '#ym-glnav';
    const arrIDs = arr;
  
    function idSet(arr=[]) {
      const idListName = arr;
      let idLists = [];
      idListName.forEach(id => {
        const ID = '#' + id;
        const tar = offcan.querySelector(ID);
        idLists.push(tar);
      });
      return idLists;
    };
  
    const idlists = idSet(arrIDs);
  
    function isElmOpen() {
      idlists.forEach(id =>{
        if (id.dataset.switchActive == 'active') {
          const inner = id.querySelector(offcanInn);
          const elmHeight = inner.offsetHeight + 1;
          const heightCheck = window.innerHeight;
          
          const root = document.querySelector(':root');
          if (elmHeight > heightCheck) {
            root.style.setProperty(offcanVar,`${heightCheck}px`);
          } else {
            root.style.setProperty(offcanVar,`${elmHeight}px`);
          }
        }
      });
    };
    
    const ff = {
      mqMax:()=>{
        idlists.forEach(elm => {
          offcan.style.height = '';
          elm.removeEventListener('click' , isElmOpen);
        });
        hamb.removeEventListener('click' , isElmOpen);
  
        window.document.removeEventListener('scroll',isElmOpen,!document.documentMode ? { passive: true } : false);
        window.removeEventListener('resize',isElmOpen,!document.documentMode ? { passive: true } : false);
      },
      mqMin:()=>{
        idlists.forEach(elm => {
          elm.addEventListener('click' , isElmOpen);
        });
        hamb.addEventListener('click' , isElmOpen);
        window.document.addEventListener('scroll',isElmOpen,!document.documentMode ? { passive: true } : false);
        window.addEventListener('resize',isElmOpen,!document.documentMode ? { passive: true } : false);
      }
    };
    switchEvent(BREAK_POPINT,ff);
    
  };
  window.glnavAreaAdjust = glnavAreaAdjust;

}

if ( typeof( window.overflowWidth ) == "undefined" ) {
  function overflowWidth(wrapCls,innCls) {
    const fixed = '.' + wrapCls; 
    const root = document.querySelector(fixed);
    function funcAdd(){
      const elmWidth = calcWidthInside(wrapCls,innCls);
      const wid = elmWidth + 30;
      root.style.width = `${wid}px`;
    };
    funcAdd(wrapCls,innCls);
    const ff = {
      mqMax:()=>{
        // root.setAttribute('style','');
        funcAdd(wrapCls,innCls);
      },
      mqMin:()=>{
        // root.setAttribute('style','');
        funcAdd(wrapCls,innCls);
      }
    };
    switchEvent(BREAK_POPINT,ff);
  }
  
  window.overflowWidth = overflowWidth;
}

function calcWidthInside(wrapCls,measureingCls,returnNum='width'){
  const arrWrapCls = Array.prototype.slice.call(document.getElementsByClassName(wrapCls));
  let re = 0;
  if (arrWrapCls) {
    arrWrapCls.forEach(e => {
      const arrMCls = Array.prototype.slice.call(e.getElementsByClassName(measureingCls));
      const arrWAll = () => {
        let sumMCls = 0 ;
        for (let i = 0; i < arrMCls.length; i++) {
          const w = arrMCls[i].offsetWidth;
    
          const getBoundingSize = (element) => {
            const { width, height } = element.getBoundingClientRect();
            return { width, height };
          };
          
          const getElementMargin = (element) => {
            const styles = window.getComputedStyle(element);
            let returnArr = {};
            ['top', 'right', 'bottom', 'left'].forEach(element => {
              returnArr[element] = parseFloat(styles.getPropertyValue(`margin-${element}`)) || 0;
            });
            return returnArr;
          };
          
          const getOuterSize = (element) => {
            const { top, right, bottom, left } = getElementMargin(element);
            const { width, height } = getBoundingSize(element);
            return {
              width: width + right + left,
              height: height + top + bottom,
            };
          };
          
          const { width, height } = getOuterSize(arrMCls[i]);
          if (returnNum === 'width') {
            sumMCls = sumMCls + width ;
          } else {
            sumMCls = sumMCls + height ;
          }
    
        };
        return sumMCls;
      }
      re = arrWAll();
    });
  };
  return re;
};

// document.addEventListener('DOMContentLoaded', function () {

//   if (document.body.id === "fs_ProductSearch") {
//     //その他
//     function priceSwap(selectionID, maxID, minID) {
//       const selector = document.getElementById(selectionID);
//       selector.addEventListener('change', function (e) {
//         const selectorVal = e.target.value.split('-');
//         const selectorMinVal = (selectorVal[0] === undefined || selectorVal[0] == 0) ? "" : selectorVal[0];
//         const selectorMaxVal = (selectorVal[1] === undefined || selectorVal[1] == 9999999) ? "" : selectorVal[1];
//         const hiddenPrice1 = document.getElementById(minID); //min
//         const hiddenPrice2 = document.getElementById(maxID); //max
//         hiddenPrice1.value = selectorMinVal;
//         hiddenPrice2.value = selectorMaxVal;
//       });
//     }
//     priceSwap('pt-value-selection__search-area', 'ym_search-area_productSearchPrice2', 'ym_search-area_productSearchPrice1');

//   }
  
// });
